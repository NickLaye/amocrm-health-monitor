name: Deploy to Production

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging

jobs:
  build:
    name: Build Application
    runs-on: ubuntu-latest
    env:
      VITE_API_URL: ${{ secrets.VITE_API_URL || 'https://amohealth.duckdns.org/api' }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '20.x'
          cache: 'npm'

      - name: Install backend dependencies
        run: npm ci

      - name: Install frontend dependencies
        run: cd client && npm install

      - name: Build frontend
        run: cd client && npm run build
        env:
          CI: false

      - name: Run tests
        run: npm test
        env:
          NODE_ENV: test
          API_SECRET: test_secret

      - name: Security audit
        run: npm audit --omit=dev --audit-level=high || true

      - name: Create deployment artifact
        run: |
          mkdir -p deploy
          cp -r server deploy/
          # Include built frontend in the deployment
          if [ -d "client/dist" ]; then
            cp -r client/dist deploy/client-build
          else
            echo "Error: client/dist not found"
            exit 1
          fi
          cp package.json deploy/
          cp package-lock.json deploy/
          cp nginx.conf deploy/ || echo "nginx.conf not found"
          cp ecosystem.config.js deploy/ || echo "ecosystem.config.js not found"
          tar -czf deploy.tar.gz deploy/

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: deployment-artifact
          path: deploy.tar.gz
          retention-days: 7

  deploy:
    name: Deploy to Server
    runs-on: ubuntu-latest
    needs: build
    if: github.ref == 'refs/heads/main'
    environment: production

    steps:
      - name: Download artifact
        uses: actions/download-artifact@v4
        with:
          name: deployment-artifact

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ secrets.SERVER_HOST }} >> ~/.ssh/known_hosts || echo "SSH setup skipped - secrets not configured"
        continue-on-error: true

      - name: Check deployment secrets
        id: check_secrets
        run: |
          if [ -z "${{ secrets.SERVER_USER }}" ] || [ -z "${{ secrets.SERVER_HOST }}" ] || [ -z "${{ secrets.DEPLOY_PATH }}" ] || [ -z "${{ secrets.SSH_PRIVATE_KEY }}" ]; then
            echo "secrets_configured=false" >> $GITHUB_OUTPUT
            echo "⚠️ Deployment secrets not configured. Skipping deployment step."
            echo "To enable auto-deployment, configure these secrets in GitHub:"
            echo "  - SERVER_USER"
            echo "  - SERVER_HOST"
            echo "  - DEPLOY_PATH"
            echo "  - SSH_PRIVATE_KEY"
          else
            echo "secrets_configured=true" >> $GITHUB_OUTPUT
            echo "✅ Deployment secrets configured. Proceeding with deployment."
          fi

      - name: Deploy to server
        if: steps.check_secrets.outputs.secrets_configured == 'true'
        env:
          SERVER_USER: ${{ secrets.SERVER_USER }}
          SERVER_HOST: ${{ secrets.SERVER_HOST }}
          DEPLOY_PATH: ${{ secrets.DEPLOY_PATH }}
        run: |
          # Ensure deployment directory exists
          ssh ${SERVER_USER}@${SERVER_HOST} "mkdir -p '${DEPLOY_PATH}'"
          
          # Copy artifact to server using rsync
          rsync -avz deploy.tar.gz "${SERVER_USER}@${SERVER_HOST}:${DEPLOY_PATH}/"
          
          # Extract and restart services
          ssh ${SERVER_USER}@${SERVER_HOST} << ENDSSH
            cd "${DEPLOY_PATH}"
            
            # Backup current version
            if [ -d "current" ]; then
              rm -rf backup
              mv current backup
            fi
            
            # Extract new version
            tar -xzf deploy.tar.gz
            mv deploy current
            cd current
            
            # Install production dependencies
            npm install --production
            
            # Copy .env file (should exist on server)
            if [ -f "../.env" ]; then
              cp ../.env .env
            else
              echo "Warning: .env file not found"
            fi
            
            # Update Nginx configuration if changed
            if [ -f "nginx.conf" ]; then
              sudo cp nginx.conf /etc/nginx/sites-available/amohealth
              sudo ln -sf /etc/nginx/sites-available/amohealth /etc/nginx/sites-enabled/
              sudo nginx -t && sudo systemctl reload nginx
              echo "✓ Nginx configuration updated"
            fi
            
            # Restart application with PM2
            echo "Current directory: $(pwd)"
            echo "Files in current directory:"
            ls -la
            echo ""
            echo "PM2 status before restart:"
            pm2 list
            
            pm2 delete amocrm-health-monitor || true
            
            # Start PM2 with ecosystem config if available, otherwise start directly
            if [ -f "ecosystem.config.js" ]; then
              echo "Starting with ecosystem.config.js"
              pm2 start ecosystem.config.js
            else
              echo "Starting with direct PM2 command"
              pm2 start server/index.js --name amocrm-health-monitor --time
            fi
            
            pm2 save
            
            echo "Waiting 10 seconds for PM2 to start..."
            sleep 10
            
            echo "PM2 status after restart:"
            pm2 list
            
            echo "PM2 logs:"
            pm2 logs amocrm-health-monitor --lines 20 --nostream || true
            
            # Check local health endpoint to ensure app is ready
            echo "Checking local health endpoint..."
            for i in {1..6}; do
              if curl -f -s http://127.0.0.1:3001/health > /dev/null 2>&1; then
                echo "✓ Local health check passed (attempt $i/6)"
                break
              else
                echo "⚠ Local health check failed (attempt $i/6), waiting 5 seconds..."
                if [ $i -eq 6 ]; then
                  echo "✗ Local health check failed after 6 attempts"
                  pm2 logs amocrm-health-monitor --lines 50 --nostream || true
                else
                  sleep 5
                fi
              fi
            done
          ENDSSH

      - name: Health check
        if: steps.check_secrets.outputs.secrets_configured == 'true'
        continue-on-error: true
        run: |
          echo "Waiting 20 seconds for application to start..."
          sleep 20
          
          echo "Checking health endpoint..."
          max_attempts=5
          attempt=1
          while [ $attempt -le $max_attempts ]; do
            echo "Attempt $attempt/$max_attempts..."
            if response=$(curl -k -s -o /dev/null -w "%{http_code}" https://${{ secrets.SERVER_HOST }}/health 2>&1); then
              echo "Response code: $response"
              if [ "$response" = "200" ]; then
                echo "✅ Deployment successful! Health check passed."
                exit 0
              else
                echo "⚠️ Health check returned status code: $response"
                if [ $attempt -lt $max_attempts ]; then
                  echo "Retrying in 5 seconds..."
                  sleep 5
                fi
              fi
            else
              echo "⚠️ Health check could not connect to server"
              if [ $attempt -lt $max_attempts ]; then
                echo "Retrying in 5 seconds..."
                sleep 5
              fi
            fi
            attempt=$((attempt + 1))
          done
          
          echo "⚠️ Health check failed after $max_attempts attempts"
          echo "Please check manually: https://${{ secrets.SERVER_HOST }}/health"
          exit 0

      - name: Rollback on failure
        if: failure() && steps.check_secrets.outputs.secrets_configured == 'true'
        continue-on-error: true
        env:
          SERVER_USER: ${{ secrets.SERVER_USER }}
          SERVER_HOST: ${{ secrets.SERVER_HOST }}
          DEPLOY_PATH: ${{ secrets.DEPLOY_PATH }}
        run: |
          ssh ${SERVER_USER}@${SERVER_HOST} << 'ENDSSH'
            cd "${DEPLOY_PATH}"
            # Restore previous version if exists
            if [ -d "backup" ]; then
              rm -rf current
              mv backup current
              cd current
              pm2 restart amocrm-health-monitor
              echo "Rolled back to previous version"
            fi
          ENDSSH

  notify:
    name: Notify Deployment Status
    runs-on: ubuntu-latest
    needs: deploy
    if: always()

    steps:
      - name: Check notification webhook
        id: check_webhook
        run: |
          if [ -z "${{ secrets.MATTERMOST_WEBHOOK_URL }}" ]; then
            echo "webhook_configured=false" >> $GITHUB_OUTPUT
            echo "⚠️ MATTERMOST_WEBHOOK_URL not configured. Skipping notification."
          else
            echo "webhook_configured=true" >> $GITHUB_OUTPUT
          fi

      - name: Send notification
        if: steps.check_webhook.outputs.webhook_configured == 'true'
        env:
          MATTERMOST_WEBHOOK: ${{ secrets.MATTERMOST_WEBHOOK_URL }}
          STATUS: ${{ needs.deploy.result }}
        run: |
          
          if [ "$STATUS" = "success" ]; then
            MESSAGE="✅ Deployment to production successful!"
            COLOR="#00ff00"
          else
            MESSAGE="❌ Deployment to production failed!"
            COLOR="#ff0000"
          fi
          
          curl -X POST ${MATTERMOST_WEBHOOK} \
            -H 'Content-Type: application/json' \
            -d "{\"text\":\"${MESSAGE}\", \"channel\":\"skypro-crm-alerts\"}"

