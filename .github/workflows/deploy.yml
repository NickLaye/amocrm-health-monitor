name: Deploy to Production

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging

jobs:
  build:
    name: Build Application
    runs-on: ubuntu-latest
    env:
      VITE_API_URL: ${{ secrets.VITE_API_URL || 'https://amohealth.duckdns.org/api' }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '20.x'
          cache: 'npm'

      - name: Install backend dependencies
        run: npm ci

      - name: Install frontend dependencies
        run: cd client && npm install

      - name: Build frontend
        run: cd client && npm run build
        env:
          CI: false

      - name: Run tests
        run: npm test
        env:
          NODE_ENV: test
          API_SECRET: test_secret

      - name: Security audit
        run: npm audit --omit=dev --audit-level=high || true

      - name: Create deployment artifact
        run: |
          mkdir -p deploy
          cp -r server deploy/
          # Include built frontend in the deployment
          if [ -d "client/dist" ]; then
            cp -r client/dist deploy/client-build
          else
            echo "Error: client/dist not found"
            exit 1
          fi
          cp package.json deploy/
          cp package-lock.json deploy/
          cp nginx.conf deploy/ || echo "nginx.conf not found"
          cp ecosystem.config.js deploy/ || echo "ecosystem.config.js not found"
          tar -czf deploy.tar.gz deploy/

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: deployment-artifact
          path: deploy.tar.gz
          retention-days: 7

  deploy:
    name: Deploy to Server
    runs-on: ubuntu-latest
    needs: build
    if: github.ref == 'refs/heads/main'
    environment: production

    steps:
      - name: Download artifact
        uses: actions/download-artifact@v4
        with:
          name: deployment-artifact

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ secrets.SERVER_HOST }} >> ~/.ssh/known_hosts || echo "SSH setup skipped - secrets not configured"
        continue-on-error: true

      - name: Check deployment secrets
        id: check_secrets
        run: |
          if [ -z "${{ secrets.SERVER_USER }}" ] || [ -z "${{ secrets.SERVER_HOST }}" ] || [ -z "${{ secrets.DEPLOY_PATH }}" ] || [ -z "${{ secrets.SSH_PRIVATE_KEY }}" ]; then
            echo "secrets_configured=false" >> $GITHUB_OUTPUT
            echo "⚠️ Deployment secrets not configured. Skipping deployment step."
            echo "To enable auto-deployment, configure these secrets in GitHub:"
            echo "  - SERVER_USER"
            echo "  - SERVER_HOST"
            echo "  - DEPLOY_PATH"
            echo "  - SSH_PRIVATE_KEY"
          else
            echo "secrets_configured=true" >> $GITHUB_OUTPUT
            echo "✅ Deployment secrets configured. Proceeding with deployment."
          fi

      - name: Deploy to server
        if: steps.check_secrets.outputs.secrets_configured == 'true'
        env:
          SERVER_USER: ${{ secrets.SERVER_USER }}
          SERVER_HOST: ${{ secrets.SERVER_HOST }}
          DEPLOY_PATH: ${{ secrets.DEPLOY_PATH }}
        run: |
          # Ensure deployment directory exists
          ssh ${SERVER_USER}@${SERVER_HOST} "mkdir -p '${DEPLOY_PATH}'"
          
          # Copy artifact to server using rsync
          rsync -avz deploy.tar.gz "${SERVER_USER}@${SERVER_HOST}:${DEPLOY_PATH}/"
          
          # Extract and restart services
          ssh ${SERVER_USER}@${SERVER_HOST} << ENDSSH
            cd "${DEPLOY_PATH}"
            
            # Backup current version
            if [ -d "current" ]; then
              rm -rf backup
              mv current backup
            fi
            
            # Extract new version
            tar -xzf deploy.tar.gz
            mv deploy current
            cd current
            
            # Install production dependencies using npm ci for reliable installs
            echo "Installing production dependencies..."
            echo "Current directory: $(pwd)"
            echo "Checking package.json and package-lock.json:"
            ls -la package.json package-lock.json 2>/dev/null || echo "Warning: package files not found"
            
            npm ci --production --no-audit --no-fund
            if [ $? -ne 0 ]; then
              echo "✗ Failed to install dependencies with npm ci, trying npm install..."
              npm install --production --no-audit --no-fund
              if [ $? -ne 0 ]; then
                echo "✗ Failed to install dependencies"
                exit 1
              fi
            fi
            echo "✓ Dependencies installed successfully"
            
            # Verify critical modules exist
            if [ ! -d "node_modules" ]; then
              echo "✗ node_modules directory not found"
              exit 1
            fi
            
            # Verify dotenv module exists (critical for startup)
            if [ ! -d "node_modules/dotenv" ]; then
              echo "✗ dotenv module not found in node_modules!"
              echo "Installed modules:"
              ls node_modules/ | head -20
              exit 1
            fi
            echo "✓ dotenv module verified"
            
            # Copy .env file (should exist on server)
            if [ -f "../.env" ]; then
              cp ../.env .env
            else
              echo "Warning: .env file not found"
            fi
            
            # Update Nginx configuration if changed
            if [ -f "nginx.conf" ]; then
              echo "Updating Nginx configuration..."
              sudo cp nginx.conf /etc/nginx/sites-available/amohealth
              sudo ln -sf /etc/nginx/sites-available/amohealth /etc/nginx/sites-enabled/
              
              # Ensure /health file doesn't exist in static directory (would interfere with proxy)
              if [ -d "client-build" ] && [ -f "client-build/health" ]; then
                echo "⚠ Removing conflicting /health file from static directory"
                rm -f client-build/health
              fi
              
              # Test configuration
              if sudo nginx -t; then
                echo "✓ Nginx configuration test passed"
                echo "Reloading Nginx..."
                sudo systemctl reload nginx
                echo "✓ Nginx reloaded"
                
                # Verify configuration was applied
                echo "Verifying Nginx configuration..."
                if sudo grep -q "location.*/health" /etc/nginx/sites-available/amohealth; then
                  echo "✓ Health check location found in Nginx config"
                  echo "Health check location details:"
                  sudo grep -A 5 "location.*/health" /etc/nginx/sites-available/amohealth || true
                else
                  echo "⚠ Health check location not found in Nginx config!"
                  echo "Available locations in config:"
                  sudo grep "location" /etc/nginx/sites-available/amohealth || true
                fi
                
                # Check Nginx error log for any issues
                echo "Checking Nginx error log (last 10 lines):"
                sudo tail -10 /var/log/nginx/amocrm-health-error.log 2>/dev/null || echo "No error log found"
                
                # Wait a moment for nginx to fully reload
                sleep 2
              else
                echo "✗ Nginx configuration test failed!"
                echo "Nginx config test output:"
                sudo nginx -t 2>&1 || true
                exit 1
              fi
            fi
            
            # Restart application with PM2
            echo "Current directory: $(pwd)"
            echo "Files in current directory:"
            ls -la
            echo ""
            echo "Checking server directory:"
            ls -la server/ | head -10 || echo "server/ directory not found"
            echo ""
            echo "Checking node_modules:"
            ls -d node_modules 2>/dev/null && echo "node_modules exists" || echo "node_modules not found"
            echo ""
            echo "PM2 status before restart:"
            pm2 list
            
            pm2 delete amocrm-health-monitor || true
            
            # Verify server/index.js exists
            if [ ! -f "server/index.js" ]; then
              echo "✗ server/index.js not found!"
              echo "Current directory contents:"
              ls -la
              exit 1
            fi
            
            # Verify we can require dotenv before starting
            echo "Verifying dotenv module can be loaded..."
            node -e "require('dotenv'); console.log('✓ dotenv module loads successfully')" || {
              echo "✗ Failed to load dotenv module"
              echo "Node version: $(node --version)"
              echo "NPM version: $(npm --version)"
              echo "Current directory: $(pwd)"
              echo "node_modules/dotenv exists: $([ -d node_modules/dotenv ] && echo 'yes' || echo 'no')"
              exit 1
            }
            
            # Start PM2 with ecosystem config if available, otherwise start directly
            if [ -f "ecosystem.config.js" ]; then
              echo "Starting with ecosystem.config.js from $(pwd)"
              pm2 start ecosystem.config.js
            else
              echo "Starting with direct PM2 command from $(pwd)"
              pm2 start server/index.js --name amocrm-health-monitor --time
            fi
            
            pm2 save
            
            echo "Waiting 10 seconds for PM2 to start..."
            sleep 10
            
            echo "PM2 status after restart:"
            pm2 list
            
            echo "PM2 logs:"
            pm2 logs amocrm-health-monitor --lines 20 --nostream || true
            
            # Check local health endpoint to ensure app is ready
            echo "Checking local health endpoint..."
            local_check_passed=false
            for i in 1 2 3 4 5 6; do
              if curl -f -s http://127.0.0.1:3001/health > /dev/null 2>&1; then
                echo "✓ Local health check passed (attempt $i/6)"
                local_check_passed=true
                
                # Also test via nginx locally if possible
                echo "Testing health endpoint via local nginx..."
                if curl -f -s http://127.0.0.1/health > /dev/null 2>&1 || curl -k -f -s https://127.0.0.1/health > /dev/null 2>&1; then
                  echo "✓ Health endpoint accessible via nginx locally"
                else
                  echo "⚠ Health endpoint not accessible via nginx locally (may need external test)"
                fi
                break
              else
                echo "⚠ Local health check failed (attempt $i/6), waiting 5 seconds..."
                if [ "$i" = "6" ]; then
                  echo "✗ Local health check failed after 6 attempts"
                  echo "PM2 process status:"
                  pm2 list || true
                  echo "PM2 logs (last 50 lines):"
                  pm2 logs amocrm-health-monitor --lines 50 --nostream || true
                  echo "PM2 error logs:"
                  pm2 logs amocrm-health-monitor --err --lines 50 --nostream || true
                else
                  sleep 5
                fi
              fi
            done
          ENDSSH

      - name: Health check
        if: steps.check_secrets.outputs.secrets_configured == 'true'
        continue-on-error: true
        run: |
          echo "Waiting 20 seconds for application to start..."
          sleep 20
          
          echo "Checking health endpoint..."
          max_attempts=5
          attempt=1
          while [ $attempt -le $max_attempts ]; do
            echo "Attempt $attempt/$max_attempts..."
            if response=$(curl -k -s -o /dev/null -w "%{http_code}" https://${{ secrets.SERVER_HOST }}/health 2>&1); then
              echo "Response code: $response"
              if [ "$response" = "200" ]; then
                echo "✅ Deployment successful! Health check passed."
                exit 0
              else
                echo "⚠️ Health check returned status code: $response"
                if [ $attempt -lt $max_attempts ]; then
                  echo "Retrying in 5 seconds..."
                  sleep 5
                fi
              fi
            else
              echo "⚠️ Health check could not connect to server"
              if [ $attempt -lt $max_attempts ]; then
                echo "Retrying in 5 seconds..."
                sleep 5
              fi
            fi
            attempt=$((attempt + 1))
          done
          
          echo "⚠️ Health check failed after $max_attempts attempts"
          echo "Please check manually: https://${{ secrets.SERVER_HOST }}/health"
          exit 0

      - name: Rollback on failure
        if: failure() && steps.check_secrets.outputs.secrets_configured == 'true'
        continue-on-error: true
        env:
          SERVER_USER: ${{ secrets.SERVER_USER }}
          SERVER_HOST: ${{ secrets.SERVER_HOST }}
          DEPLOY_PATH: ${{ secrets.DEPLOY_PATH }}
        run: |
          ssh ${SERVER_USER}@${SERVER_HOST} << 'ENDSSH'
            cd "${DEPLOY_PATH}"
            # Restore previous version if exists
            if [ -d "backup" ]; then
              rm -rf current
              mv backup current
              cd current
              pm2 restart amocrm-health-monitor
              echo "Rolled back to previous version"
            fi
          ENDSSH

  notify:
    name: Notify Deployment Status
    runs-on: ubuntu-latest
    needs: deploy
    if: always()

    steps:
      - name: Check notification webhook
        id: check_webhook
        run: |
          if [ -z "${{ secrets.MATTERMOST_WEBHOOK_URL }}" ]; then
            echo "webhook_configured=false" >> $GITHUB_OUTPUT
            echo "⚠️ MATTERMOST_WEBHOOK_URL not configured. Skipping notification."
          else
            echo "webhook_configured=true" >> $GITHUB_OUTPUT
          fi

      - name: Send notification
        if: steps.check_webhook.outputs.webhook_configured == 'true'
        env:
          MATTERMOST_WEBHOOK: ${{ secrets.MATTERMOST_WEBHOOK_URL }}
          STATUS: ${{ needs.deploy.result }}
        run: |
          
          if [ "$STATUS" = "success" ]; then
            MESSAGE="✅ Deployment to production successful!"
            COLOR="#00ff00"
          else
            MESSAGE="❌ Deployment to production failed!"
            COLOR="#ff0000"
          fi
          
          curl -X POST ${MATTERMOST_WEBHOOK} \
            -H 'Content-Type: application/json' \
            -d "{\"text\":\"${MESSAGE}\", \"channel\":\"skypro-crm-alerts\"}"

