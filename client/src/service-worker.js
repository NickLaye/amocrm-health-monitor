import { clientsClaim } from 'workbox-core';
import {
  cleanupOutdatedCaches,
  createHandlerBoundToURL,
  precacheAndRoute,
} from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { StaleWhileRevalidate } from 'workbox-strategies';
import { CacheableResponsePlugin } from 'workbox-cacheable-response';

// Precache all of the assets generated by Vite.
// self.__WB_MANIFEST is replaced at build time by vite-plugin-pwa.
precacheAndRoute(self.__WB_MANIFEST);
cleanupOutdatedCaches();

self.skipWaiting();
clientsClaim();

const APP_SHELL_URL = '/index.html';
const createShellHandler = () => createHandlerBoundToURL(APP_SHELL_URL);
let shellHandler = createShellHandler();

// Navigation requests: serve the cached app shell, fallback to network when available.
registerRoute(
  ({ request }) => request.mode === 'navigate',
  async (options) => {
    try {
      return await shellHandler(options);
    } catch (error) {
      const cachedShell = await caches.match(APP_SHELL_URL);
      if (cachedShell) {
        return cachedShell;
      }
      throw error;
    }
  }
);

// Cache bust helper when the manifest is updated at runtime.
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'RESET_SHELL_HANDLER') {
    shellHandler = createShellHandler();
  }
});

// Cache hashed Vite assets (dist/assets/...) with stale-while-revalidate strategy.
registerRoute(
  ({ url }) =>
    url.origin === self.location.origin &&
    url.pathname.startsWith('/assets/'),
  new StaleWhileRevalidate({
    cacheName: 'amocrm-vite-assets',
    plugins: [new CacheableResponsePlugin({ statuses: [200] })],
  })
);

// Cache additional static resources (fonts, scripts, styles) that may reside outside /assets.
registerRoute(
  ({ request, url }) =>
    url.origin === self.location.origin &&
    ['style', 'script', 'font'].includes(request.destination) &&
    !url.pathname.startsWith('/assets/'),
  new StaleWhileRevalidate({
    cacheName: 'amocrm-static-resources',
    plugins: [new CacheableResponsePlugin({ statuses: [200] })],
  })
);

// API and SSE calls should bypass caches but still provide an offline fallback.
self.addEventListener('fetch', (event) => {
  const { request } = event;
  const url = new URL(request.url);

  if (url.origin !== self.location.origin) {
    return;
  }

  if (url.pathname.startsWith('/api/')) {
    event.respondWith(
      fetch(request).catch(() =>
        new Response(
          JSON.stringify({
            error: 'Offline',
            message: 'Вы сейчас офлайн. Данные API недоступны.',
          }),
          {
            headers: { 'Content-Type': 'application/json' },
            status: 503,
          }
        )
      )
    );
  }
});

// Background sync placeholder for failed API requests.
self.addEventListener('sync', (event) => {
  if (event.tag === 'sync-data') {
    event.waitUntil(Promise.resolve());
  }
});

// Push notification support.
self.addEventListener('push', (event) => {
  const data = event.data ? event.data.json() : {};
  const title = data.title || 'amoCRM Health Monitor';
  const options = {
    body: data.body || 'Новое уведомление',
    icon: '/favicon.svg',
    badge: '/favicon.svg',
    vibrate: [200, 100, 200],
    data: data.url ? { url: data.url } : {},
    actions: [
      { action: 'view', title: 'Открыть' },
      { action: 'close', title: 'Закрыть' },
    ],
  };

  event.waitUntil(self.registration.showNotification(title, options));
});

// Handle notification click actions.
self.addEventListener('notificationclick', (event) => {
  event.notification.close();

  if (event.action === 'view' && event.notification.data?.url) {
    event.waitUntil(clients.openWindow(event.notification.data.url));
  }
});


